\subsection{Wymagania i założenia}

Po pierwsze Lupus ma przyjąć rolę \textit{regulatora} (ang. \textit{Control System}) znanego z teorii sterowania. Regulowanymi systemami mają być w tym przypadku systemy telekomunikacyjne. Aby odegrać rolę ENI System, platforma musi być w stanie zamodelować oraz uruchomić \underbar{dowolną} zamkniętą pętle sterowania, zwłaszcza te zawarte w \cite{enioverview}. 

Z racji ogólności systemu oraz zwiększenia szansy na pozytywne przyjęcie w społeczności wybrano Kubernetes jako infrastrukturę dla platformy. Kubernetes natywnie używa zamkniętych pętli sterowania w swojej warstwie sterowania (ang. \textit{control plane}), z których użytkownik jest w stanie skorzystać za pomocą mechanizmów rozszerzeń Kubernetes takich jak \textit{Definicje Zasobów Własnych} (ang. \textit{Custom Resource Definitions (CRD)} oraz \textit{Wzorzec Operatora} (ang. )\textit{Operator Pattern}). Są to mechanizmy dobrze znane w branży. 

Wybór Kubernetes narzuca jednakże pewne ograniczenie. Regulowane procesy nie mogą odbywać się w czasie rzeczywistym. Warstwa sterowania Kubernetes działa nieco wolniej. 

Lupus musi być "data-driven" co na polski można przetłumaczyć jako "sterowany danymi". Oznacza to, że platforma nie może narzucać żadnej postaci logiki pętli. Warstwa sterowania Kubernetes musi być w stanie interpretować zamiary użytkownika platformy, który może wyrazić dowolną pętle. Zamiary te wyrażone są właśnie w danych. 

Logikę pętli możemy podzielić na dwie części: workflow pętli oraz części obliczeniowa. Workflow jest to zdefiniowane elementów oraz relacji między nimi. Częścią obliczeniową za to nazywamy procesowanie wykonywane przez konkretne elementy. Z racji podejścia "data-driven" nie możemy zaszyć części obliczeniowej w warstwie sterowania Kubernetes. Dlatego elementy odpowiedzialne za części obliczeniową są "na zewnątrz" pętli Lupus, przykładowo są to serwery HTTP, do których Lupus wykonując pętle może się odwołać.

Z tego opisu powstaje garść wymagań oraz założeń, które nie są zbiorami rozłącznymi i wielu miejscach się zacierają, jednakże warto wyszczególnić je w sposób wylistowany poniżej, aby móc łatwiej się do nich odwoływać w dalszej części pracy:

\begin{enumerate}
    \item \label{req:1} Lupus jest skierowany do branży telekomunikacyjnej.
    \item \label{req:2} Lupus umożliwia modelowanie i uruchamianie dowolnych architektur zamkniętych pętli sterowania, w szczególności tych zaproponowanych w \cite{enioverview}.
    \item \label{req:3} Lupus zarządza procesami, które nie wymagają regulacji w czasie rzeczywistym (są "non-realtime").
    \item \label{req:4} Lupus jest zaimplementowany na bazie Kubernetes, wykorzystując jego \textit{Controller Pattern}.
    \item \label{req:5} Lupus jest oparty na danych (\textit{data-driven}), co oznacza, że nie narzuca i nie ma wbudowanej żadnej domyślnej logiki pętli.
    \item \label{req:6} Faktyczne komponenty przetwarzające w pętli (część obliczeniowa) Lupus są zewnętrzne względem niego (np. serwery HTTP, szczególnie Open Policy Agent).
    \item \label{req:7} Lupus powinien być w stanie regulować pracą dowolnego systemu teleinformatycznego bez żadnych jego modyfikacji.
    \item \label{req:8} Zamodelowanie pętli oraz wyrażenie jej \hyperlink{def:workflow-petli}{\textbf{Workflow}} w Lupus nie powinno wymagać umiejętności technicznych.
\end{enumerate}

Powyższa lista nazwana jest Wymaganiami i referowana w dalszej części dokumentu. 
